{"version":3,"file":"simple-mask.js","sourceRoot":"","sources":["../package/src/simple-mask.ts"],"names":[],"mappings":"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","sourcesContent":["export class SimpleMask {\n  protected patterns: any = {\n    '9': new RegExp('[0-9]'),\n    'a': new RegExp('[a-z]'),\n    'A': new RegExp('[A-Z]'),\n    'x': new RegExp('[a-zA-Z]'),\n    '*': new RegExp('[a-zA-Z0-9]'),\n    '~': new RegExp('[-\\+]')\n  };\n  mask: string;\n  fillWithExpected: boolean;\n\n  /**\n   * set new patterns\n   * @param patterns new patterns\n   * @param clear true if to clear old patterns\n   */\n  protected setPatterns(patterns: any, clear: boolean = false): void {\n    if (!patterns) {\n      return;\n    }\n    try {\n      JSON.parse(JSON.stringify(patterns));\n    } catch {\n      throw new Error('Invalid patterns object');\n    }\n    if (clear) {\n      this.patterns = {};\n    }\n    for (const key in patterns) {\n      if (patterns.hasOwnProperty(key)) {\n        this.patterns[key] = new RegExp(patterns[key]);\n      }\n    }\n  }\n\n  /**\n   * checks if the char is a pattern, that is, if is a pattern\n   * @param char value to check\n   * @returns true is a pattern, false if is not\n   */\n  protected isPattern(char: string): boolean {\n    for (const key in this.patterns) {\n      if (this.patterns.hasOwnProperty(key) && key === char) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Fits the value with the mask and return a formatted value\n   * @param value value to fit\n   * @returns formatted value\n   */\n  protected fitToMask(value: string): string {\n    let newValue = '';\n    // value size adjust to mask size\n    const size = this.mask.replace(/\\\\(?!\\\\)/g, '').length;\n    value = value.substring(0, size);\n\n    if (this.fillWithExpected) {\n      let i = 0;\n      let prefix = true;\n      for (let j = 0; j < this.mask.length; j++) {\n        // ignore next special char\n        if (this.mask[j] === '\\\\') {\n          newValue += this.mask[j + 1];\n          j++;\n          continue;\n        }\n        // test special char\n        if (this.isPattern(this.mask[j])) {\n          if (this.patterns[this.mask[j]].test(value[i])) {\n            newValue += value[i];\n            i++;\n          } else {\n            return newValue;\n          }\n        } else {\n          if (prefix && !value[i]) {\n            return newValue;\n          }\n          newValue += this.mask[j];\n          if (this.mask[j] === value[i] && prefix) {\n            i++;\n          } else {\n            prefix = false;\n          }\n        }\n      }\n    } else {\n      for (let i = 0, j = 0; j < this.mask.length && i < value.length; i++ , j++) {\n        // ignore next special char\n        if (this.mask[j] === '\\\\') {\n          newValue += this.mask[j + 1];\n          j++;\n          continue;\n        }\n        // test special char\n        if (this.isPattern(this.mask[j])) {\n          if (this.patterns[this.mask[j]].test(value[i])) {\n            newValue += value[i];\n          } else {\n            return newValue;\n          }\n        } else {\n          newValue += this.mask[j];\n  \n          if (this.mask[j] !== value[i]) {\n            i--;\n          }\n        }\n      }\n    }\n\n    return newValue;\n  }\n}"]}